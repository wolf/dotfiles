#!/usr/bin/env bash

# shellcheck disable=SC1091
source "${DOTFILES_DIR}/bash/test/platform.inc"

if [ "$(command -v fdfind)" ] && [ ! "$(command -v fd)" ] ; then
    function fd() {
        /usr/lib/cargo/bin/fd "$@"
    }
fi

setUp() {
    unset CDPATH
    cd "${DOTFILES_DIR}/bash" || return

    if [ "$(platform)" == linux ] ; then
        # shellcheck disable=SC1091
        source ".bash_topics.d/linux/fd.bash"
    else
        # shellcheck disable=SC1091
        source ".bash_topics.d/fd.bash"
    fi
}

test_f_finds_ordinary_file() {
    local FOUND
    FOUND="$(f --color=never test_f_finds_ordinary_file.data)"
    FOUND="${FOUND#./}"
    # shellcheck disable=SC2016
    assertTrue "didn't find anything at all!" '[ "${FOUND}" ]'
    assertEquals "didn't find the right file!" "test/data/test_f_finds_ordinary_file.data" "${FOUND}"
}

# test f finds a hidden file
test_f_finds_hidden_file() {
    local FOUND
    FOUND="$(f --color=never test_f_finds_hidden_file.data)"
    FOUND="${FOUND#./}"
    # shellcheck disable=SC2016
    assertTrue "didn't find anything at all!" '[ "${FOUND}" ]'
    assertEquals "didn't find the hidden file!" "test/.hidden_data/test_f_finds_hidden_file.data" "${FOUND}"
}

test_f_fails_silently() {
    f "test_f_fails_silently.data"
    assertTrue "didn't fail silently!" "[ $? ]"
}

# test f can be made to not find an ignored file
test_f_ignores_file() {
    local FOUND
    cd "${DOTFILES_DIR}" || return
    FOUND="$(f --ignore --color=never ".git")"
    assertEquals "did not ignore .git!" "" "${FOUND}"
}

# test f finds multiple files in multiple different directories at the same time
test_f_finds_multiple_files() {
    local OUTPUT
    local GOLDEN_RECORD
    OUTPUT="$(f --regex "^test_fe_[12]\.data$" | sed 's=\./==g')"
    GOLDEN_RECORD="test/.hidden_data/test_fe_2.data"$'\n'"test/data/test_fe_1.data"
    assertEquals "didn't find both files!" "${GOLDEN_RECORD}" "${OUTPUT}"
}

# test f follows a symbolic link
test_f_follows_symbolic_links() {
    local RANDOM_STRING
    local FOUND

    [ "$(platform)" = "msys" ] && startSkipping

    # make a link in /tmp that leads to test/data
    RANDOM_STRING="$(python3 -c "import uuid; print(str(uuid.uuid4()),end='')")"
    ln -s "${DOTFILES_DIR}/bash/test/data" "/tmp/${RANDOM_STRING}"
    # search /tmp for a file in test/data
    FOUND="$(f --color=never test_f_finds_ordinary_file.data /tmp)"
    # shellcheck disable=SC2016
    assertTrue "didn't find anything at all!" '[ "${FOUND}" ]'
    assertEquals "didn't find the right file!" "/tmp/${RANDOM_STRING}/test_f_finds_ordinary_file.data" "${FOUND}"
    # remove the link in /tmp
    rm "/tmp/${RANDOM_STRING}"
}

# test f finds a file specified by a glob
test_f_finds_globs() {
    local COUNT
    COUNT=$(f --glob '*.data' | wc -l)
    assertTrue "f didn't find anything that matched that glob!" "(( ${COUNT} > 0 ))"
}

# test f finds a directory
test_f_finds_a_directory() {
    local FOUND
    FOUND="$(f --color=never .hidden_data)"
    FOUND="${FOUND#./}"
    assertEquals "directory not found!" "test/.hidden_data" "${FOUND}"
}

# test fcat can actually cat a file
test_fcat() {
    local COUNT
    COUNT=$(fcat --glob '*.data' | wc -l)
    assertTrue "fcat didn't produce any output!" "(( ${COUNT} > 0 ))"
}

test_fcd_changes_directory() {
    local OLD_DIR
    local NEW_DIR
    OLD_DIR="$(pwd)"
    fcd ".hidden_data"
    NEW_DIR="$(pwd)"
    assertNotEquals "should have changed directories!" "${OLD_DIR}" "${NEW_DIR}"
    assertEquals "got the wrong destination!" "${HOME}/builds/dotfiles/bash/test/.hidden_data" "${NEW_DIR}"
}

# test fcd fails silently?
test_fcd_fails_silently() {
    local OLD_DIR
    local NEW_DIR
    OLD_DIR="$(pwd)"
    fcd "nonexistent_directory"
    assertTrue "fcd didn't fail silently" "[ $? ]"
    NEW_DIR="$(pwd)"
    assertEquals "shouldn't have changed directories!" "${OLD_DIR}" "${NEW_DIR}"
}

# test fcd_of finds the parent directory of a specific file-system object
test_fcd_of() {
    local OLD_DIR
    local NEW_DIR
    OLD_DIR="$(pwd)"
    fcd_of "test_f_finds_hidden_file.data"
    NEW_DIR="$(pwd)"
    assertNotEquals "should have changed directories!" "${OLD_DIR}" "${NEW_DIR}"
    assertEquals "got the wrong destination!" "${HOME}/builds/dotfiles/bash/test/.hidden_data" "${NEW_DIR}"
}

# fe, can't test?  What if I set EDITOR to something _non_-interactive
test_fe() {
    # shellcheck disable=SC2034
    local EDITOR=echo
    local OUTPUT
    OUTPUT="$(fe --regex "^test_fe_[12]\.data$" | sed 's=\./==g')"
    assertEquals "files weren't opened!" "test/.hidden_data/test_fe_2.data test/data/test_fe_1.data" "${OUTPUT}"
}

# test fll produces output
test_fll() {
    local COUNT
    COUNT=$(fll --glob '*.data' | wc -l)
    assertTrue "fll didn't produce any output!" "(( ${COUNT} > 0 ))"
}

# test fsource loads a function definition
test_fsource() {
    fsource 'test_fsource.data' >/dev/null
    assertTrue "sourced definition wasn't found!" "[ $(command -v test_fsource_sample_function_definition) ]"
}

# shellcheck disable=SC1090
source "$(which shunit2)"
